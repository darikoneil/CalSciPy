from __future__ import annotations
from typing import List, Iterator, Tuple, Optional, Union, Mapping, Iterable
from pathlib import Path
from contextlib import suppress


"""
Objects for organizing files

"""


class FileTree:
    """
    A file tree that organizes experiment data, analyzed results, and figures. For implementation concerns it is not
    an extension of the built-in dictionary type, but it replicates the following of its built-in methods:
    clear | get | items | iter | keys | len | pop | popitem | values
    """

    def __init__(self, name: str, base_directory: Path, **kwargs):
        """
        A file tree that organizes experiment data, analyzed results, and figures. For implementation concerns it is not
        an extension of the built-in dictionary type, but it replicates the following of its built-in methods:

        :param name: name of experiment

        :param base_directory: base directory of mouse

        :param kwargs: key-value pairs passed to and incorporated into the file tree. Can be file sets, paths, etc

        """
        #: str: name of experiment
        self._name = name

        #: :class:`Path <pathlib.Path>`: directory of experiment generated by combining base directory
        #   and name of experiment
        self.directory = base_directory.joinpath(name)
        if not self.directory.exists():
            self.directory.mkdir()

        # remove experiment name from kwargs so it's not incorporated into file tree
        if "name" in kwargs:
            kwargs.pop("name")

        # remove base directory from kwargs so it's not incorporated into file tree
        if "base_directory" in kwargs:
            kwargs.pop("base_directory")

        # finally set attributes
        for key, value in kwargs.items():
            setattr(self, key, value)

    def add_path(self, key: str) -> FileTree:
        """
        Adds a file set to the file tree

        :param key: key for this file set. Should be "folder" not a full path or literal

        """
        setattr(self, key, FileSet(key, self.directory))

    def build(self) -> FileTree:
        """
        Builds the file-tree by initializing any file sets that do not yet exist

        """
        for value in self.values():
            if isinstance(value, FileSet):
                if not value.directory.exists():
                    value.directory.mkdir()

    def clear(self) -> FileTree:
        """
        Clears the Filetree of all filesets

        """
        try:
            while True:
                self.popitem()
        except KeyError:
            pass  # try except pass is okay here; run pop until it raises a key error indicating it's finished

    def get(self, key: str) -> FileSet:
        """
        Returns the file set associated with some key

        :param key: key of specific file set

        """
        return self.__getattribute__(key)

    def items(self) -> Tuple[str, FileSet]:
        """
        Collects the key-value pairs of the filetree

        """
        return [(key, value) for key, value in vars(self).items() if isinstance(value, FileSet)]

    def iter(self) -> Iterator:
        """
        Returns an iterator over the filesets keys in the filetree

        """
        return iter(self.keys())

    def keys(self) -> List[str]:
        """
        Collects the keys (filesets) of the file tree

        """
        return [key for key, _ in self.items()]  # items call guarantees filesets only

    def pop(self, key: str) -> FileSet:
        """
        If the fileset or some other attribute indicated by key is in the filetree, then remove it and return it.

        Returns KeyError otherwise

        """
        if key in self.keys():  # Make sure we don't pop anything important
            return vars(self).pop(key)
        else:
            raise KeyError

    def popitem(self) -> FileSet:
        """
        Remove and return a fileset from the filetree. LIFO order guarantee. If the filetree contains no filesets
        raises KeyError

        """
        key = self.keys()[-1]
        return self.pop(key)

    def reindex(self) -> FileTree:
        """
        Reindex the file tree to find newly added files

        """
        for key, _ in self.items():  # items call guarantees filesets only
            self.get(key).reindex()

    def remap(self, base_directory: Path) -> FileTree:
        """
        Remap the fileset to a new location after moving the folder

        :param base_directory: base directory of mouse

        """
        self.directory = base_directory.joinpath(self._name)
        for key in self.keys():
            self.get(key).remap(self.directory)

    def validate(self) -> FileTree:
        """
        Validates that the existing filesets still exist and contain the prescribed files

        """
        for value in self.values():
            value.validate()

    def values(self) -> List[FileSet]:
        """
        Returns filesets

        """
        return [value for _, value in self.items()]    # items call guarantees filesets only

    def __call__(self, target: str = None) -> Path:
        """
        Call the file tree for a specific file or folder and return its Path. If no target provided,
        the file tree directory is returned. If multiple paths meet the target criterion a key error is raised.
        If no path meets the target criterion a file not found error is raised.

        :param target: file or folder name

        """
        if target:
            with suppress(FileNotFoundError):
                files = [fileset(target) for fileset in self.values()]
            if len(files == 0):
                raise FileNotFoundError
            if len(files > 1):
                raise KeyError
            return files[0]
        else:
            return self.directory

    def __len__(self) -> int:
        """
        Implementation of length magic method. Returns number of filesets

        """
        return len(self.keys())


class FileSet:
    """
    Organizing class for a set of files. Contents may be only files or a collection of folders and files.
    It is useful in managing coherent sets of data like experimental sessions or a calendar day. It offers several
    methods for keeping track of datasets like file validation and easy access to full file paths
    using filename keys.

    """

    def __init__(self, name: str, parent_directory: Path):
        """
        Organizing class for a set of files. Contents may be only files or a collection of folders and files.
        It is useful in managing coherent sets of data like experimental sessions or a calendar day. It offers several
        methods for keeping track of datasets like file validation and easy access to full file paths
        using filename keys.

        :param name: Name of file set

        :param parent_directory: Parent directory (filetree)

        """
        #: str: name of file set
        self._name = name

        #: :class:`Path <pathlib.Path>`: File set directory
        self.directory = parent_directory.joinpath(name)

        #: :class:`dict`: Files cache
        self._files = {}  # files cache

        #: :class:`dict`: Folders cache
        self._folders = {}  # folders cache

    @property
    def files(self) -> dict:
        """
        :Getter: Returns the files in the file set (cached)
        :Getter Type: :class:`dict`
        :Setter: This property cannot be set

        """
        return self._files

    @property
    def folders(self) -> dict:
        """
        :Getter: Returns the folders in the file set (cached)
        :Getter Type: :class:`dict`
        :Setter: This property cannot be set

        """
        return self._folders

    def find_file_type(self, ext: str) -> Optional[List[Path]]:
        """
        Returns all files with a specified extension

        :param ext: Specified file extension

        :type ext: :class:`Optional <typing.Optional>`\[:class:`List <typing.List>`\[:class:`Path <pathlib.Path>`\]]

        """
        if "." not in ext:
            ext = "".join([".", ext])
        return [file for file in self.files.values() if file.suffix == ext]

    def find_matching_files(self, identifier: str) -> Optional[List[Path]]:
        """
        Returns all files that match some identifier

        :param identifier: String identified to match

        :rtype: :class:`Optional <typing.Optional>`\[:class:`List <typing.List>`\[:class:`Path <pathlib.Path>`\]]

        """
        return [file for file in self.files.values() if file.match(identifier)]

    def reindex(self) -> FileSet:
        """
        Re-indexes the files and folders cache

        """
        self._files = FileMap()
        self._folders = FileMap()
        self._files.update([(file.stem, file) for file in self.directory.rglob("*") if file.is_file()])
        self._folders.update([(folder.stem, folder) for folder in self.directory.rglob("*") if not folder.is_file()])

    def remap(self, parent_directory: Path) -> FileSet:
        """
        Remaps all files and folders in the file set following a change in the parent directory or parent file tree

        :param parent_directory: Parent directory

        """
        self.directory = parent_directory.joinpath(self._name)
        self.reindex()

    def validate(self) -> FileSet:
        """
        Validates all files and folders in cache still exist

        """
        for name, location in self.files.items():
            if not location.exists():
                raise FileNotFoundError(f"{name}")

    def __call__(self, target: str = None) -> Path:
        """
        Call the fileset using a specific target file or folder name and return the associated path

        :param target: file or folder name

        """
        if target:
            try:
                return self.files.get(target)
            except KeyError:
                try:
                    return self.folders.get(target)
                except KeyError:
                    raise FileNotFoundError("Could not find target")
        if not target:
            return self.directory


class FileMap(dict):
    """
    Dictionary extension that appends an integer to duplicate keys before storing as a new key-value pair
    rather than overwriting the existing key-value pair.

    """

    def update(self, __m: Union[Mapping, Iterable], **kwargs) -> None:  # noqa: U100, ANN001, F821
        """
        Updates the dictionary

        """
        # kwargs is not used except as protection. refactoring might be something to consider
        if isinstance(__m, Mapping):
            for key, value in __m.items():
                self.__setitem__(key, value)
        elif isinstance(__m, Iterable):
            for key, value in __m:
                self.__setitem__(key, value)
        else:
            pass

    def __setitem__(self, key: str, value: Path):
        if key in self:
            base_key = key
            key_index = 0
            while key in self:
                key_index += 1
                key = "".join([base_key, str(key_index)])
        super().__setitem__(key, value)
